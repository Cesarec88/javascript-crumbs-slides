<!DOCTYPE html>
<html>

<head>
<style>

body {
  font-family: Helvetica Neue;
  font-size: 20px;
}

</style>
</head>

<body>


<article>
<h1>Inheritance</h1>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Inheritance through prototype chain</h2>

<h3>A first geometric example</h3>

<div class="highlight"><pre lang="js">function Shape(){
  this.name = 'shape';
  this.toString = function() { return this.name; };
}

function TwoDShape(){
  this.name = '2D shape';
}
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Inheritance through prototype chain</h2>

<h3>A first geometric example</h3>

<p>Here is the inheritance magic code:</p>

<div class="highlight"><pre lang="js">TwoDShape.prototype = new Shape();
TwoDShape.prototype.constructor = TwoDShape;
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Inheritance through prototype chain</h2>

<h3>A first geometric example: explanation</h3>

<p>We completely overwrote the object in the <code>prototype</code> property of <code>TwoDShape</code> with another object, created by invoking the <code>Shape()</code> constructor with <code>new</code>.  </p>

<p>The important thing to note is that JavaScript works with objects, not classes.  </p>

<p>An <strong>instance</strong> is created using the <code>new Shape()</code> constructor and after that its properties can be inherited;  </p>

<p>After inheriting, whatever modification to <code>Shape()</code> function, will have no effect on <code>TwoDShape</code>.<br />This is because inheritance works on one instance: the instance to inherit from.  </p>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Inheritance through prototype chain</h2>

<h3>A first geometric example</h3>

<p>Now test it:</p>

<div class="highlight"><pre lang="js">var tds = new TwoDShape();
tds.toString(); // "2D shape"
</pre></div>

<blockquote>
  <h4>Note</h4>
  
  <p>the inherited method <code>toString()</code> binds the <code>this</code> object to <code>tri</code>.  </p>
</blockquote>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Inheritance through prototype chain</h2>

<h3>A second geometric example</h3>

<div class="highlight"><pre lang="js">function Triangle(side, height) {
  this.name = 'Triangle';
  this.side = side;
  this.height = height;
    this.getArea = function() { return this.side * this.height / 2; };
}
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Inheritance through prototype chain</h2>

<h3>A second geometric example</h3>

<p>Here is the inheritance magic code:</p>

<div class="highlight"><pre lang="js">Triangle.prototype = new TwoDShape();
Triangle.prototype.constructor = Triangle;
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Inheritance through prototype chain</h2>

<h3>A second geometric example</h3>

<p>Now test it</p>

<div class="highlight"><pre lang="js">var tri = new Triangle(5, 10);
tri.getArea(); //25
</pre></div>

<div class="highlight"><pre lang="js">tri.toString() //"Triangle"
</pre></div>

<blockquote>
  <h4>Note</h4>
  
  <p>the inherited method <code>toString()</code> binds the <code>this</code> object to <code>tri</code>.  </p>
</blockquote>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Inheritance through prototype chain</h2>

<h3>What exactly happen</h3>

<p>Here is what the JavaScript engine does when you call <code>my.toString()</code>:</p>

<ol>
<li>it loops through all of the properties of <code>tri</code> and doesn't find a method called <code>toString()</code>;</li>
<li>it looks at the object that <code>my.__proto__</code> points to; this object is the instance <code>new TwoDShape()</code> created during the inheritance process.</li>
<li>now the JavaScript engine loops through the instance of <code>TwoDShape</code> and doesn't find a <code>toString()</code> method. It then checks the <code>__proto__</code> of that object. This time <code>__proto__</code> points to the instance created by <code>new Shape()</code>;</li>
<li>the instance of <code>new Shape()</code> is examined and <code>toString()</code> is finally found;</li>
<li>this method is invoked in the context of <code>tri</code>, meaning that <code>this</code> points to <code>tri</code>.</li>
</ol>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Inheritance through prototype chain</h2>

<h3>Some tests</h3>

<div class="highlight"><pre lang="js">tri.constructor; // Triangle(side, height)
</pre></div>

<div class="highlight"><pre lang="js">tri instanceof Shape     // true
tri instanceof TwoDShape // true
tri instanceof Triangle  // true
tri instanceof Array     // false
</pre></div>

<div class="highlight"><pre lang="js">Shape.prototype.isPrototypeOf(tri)     // true
TwoDShape.prototype.isPrototypeOf(tri) // true
Triangle.prototype.isPrototypeOf(tri)  // true
String.prototype.isPrototypeOf(tri)    // false
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Inheritance through prototype chain</h2>

<h3>A second geometric example - the end</h3>

<p>Of course, it's possible to create objects using the other two constructors.</p>

<div class="highlight"><pre lang="js">var td = new TwoDShape();
td.constructor; // TwoDShape()
td.toString()
var s = new Shape();
s.constructor; // Shape()
</pre></div>
</article>


<!-- slide -->


<article>
<h2>Moving shared properties to the prototype</h2>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Moving shared properties to the prototype</h2>

<h3>The wrog way</h3>

<div class="highlight"><pre lang="js">function Shape() {
  this.name = 'shape';
}
</pre></div>

<p>In this way, every time new object is created using <code>new Shape()</code>, <br /><br />a new <code>name</code> property will be created and stored somewhere in memory. </p>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Moving shared properties to the prototype</h2>

<h3>The right way</h3>

<div class="highlight"><pre lang="js">function Shape() {}
Shape.prototype.name = 'shape';
</pre></div>

<p>In this way every time an object is created using <code>new Shape()</code>, <br /><br />this object will not have its own property <code>name</code>, <br /><br />but will use the one added to the prototype.  </p>

<p>This is more efficient, but you should only use it for properties <br /><br />that don't change from one instance to another  </p>

<p>Methods are ideal for this type of sharing.  </p>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Moving shared properties to the prototype</h2>

<h3>The right way</h3>

<blockquote>
  <h3>Tip</h3>
  
  <p>for reasons of efficiency, it's good to add the reusable properties and methods to the prototype.</p>
</blockquote>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Moving shared properties to the prototype</h2>

<h3>Improving the geometric example</h3>

<div class="highlight"><pre lang="js">function Shape() {}

// augment prototype
Shape.prototype.name = 'shape';
Shape.prototype.toString = function() { 
    return this.name; 
};
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Moving shared properties to the prototype</h2>

<h3>Improoving the geometric example</h3>

<div class="highlight"><pre lang="js">function TwoDShape() {}

// take care of inheritance first before augmenting the prototype,
// otherwise anything you add to TwoDShape.prototype will be wiped out when you inherit.
TwoDShape.prototype = new Shape();
TwoDShape.prototype.constructor = TwoDShape;

// augment prototype
TwoDShape.prototype.name = '2D shape';
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Moving shared properties to the prototype</h2>

<h3>Improving the geometric example</h3>

<div class="highlight"><pre lang="js">function Triangle(side, height) {
  this.side = side;
  this.height = height;
}

// take care of inheritance first before augmenting the prototype,
Triangle.prototype = new TwoDShape();
Triangle.prototype.constructor = Triangle;

// augment prototype
Triangle.prototype.name = 'Triangle';
Triangle.prototype.getArea = function() { return this.side * this.height / 2; };
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Moving shared properties to the prototype</h2>

<h3>Testing the improved geometric example</h3>

<div class="highlight"><pre lang="js">var tri = new Triangle(5, 10);
tri.getArea();  // 25
tri.toString(); // "Triangle"

tri.hasOwnProperty('side'); // true
tri.hasOwnProperty('name'); // false

TwoDShape.prototype.isPrototypeOf(tri); // true
tri instanceof Shape // true
</pre></div>
</article>


<!-- slide -->


<article>
<h2>Inheriting the prototype only</h2>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Inheriting the prototype only</h2>

<h3>How to do it</h3>

<p>Inheriting the object contained in <code>Shape.prototype</code> could be better than inheriting the object created with <code>new Shape()</code>.  </p>

<div class="highlight"><pre lang="js">function Shape() {}

// augment prototype
Shape.prototype.name = 'shape';
Shape.prototype.toString = function() {return this.name;};


function Triangle(side, height) {
  this.side = side;
  this.height = height;
}

// take care of inheritance
Triangle.prototype = Shape.prototype;
Triangle.prototype.constructor = Triangle;

// augment prototype
Triangle.prototype.name = 'Triangle';
Triangle.prototype.getArea = function() { return this.side * this.height / 2; }
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Inheriting the prototype only</h2>

<h3>Testing this approach</h3>

<div class="highlight"><pre lang="js">var tri = new Triangle(5, 10);
tri.getArea();  // 25
tri.toString(); // "Triangle"
</pre></div>

<p>So the lookup is only a two-step process as opposed to four.  </p>

<p>Simply copying the prototype is more efficient but it has a side effect:</p>

<div class="highlight"><pre lang="js">var s = new Shape();
s.name // "Triangle"
</pre></div>
</article>


<!-- slide -->


<article>
<h2>A temporary constructor <code>new F()</code></h2>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>A temporary constructor <code>new F()</code></h2>

<h3>Explanation</h3>

<p>A solution to the problem outlined above, is to use an intermediary to break the chain. <br /><br />The intermediary is in the form of a temporary constructor function.  </p>

<p>Creating an empty function <code>F()</code> and setting its prototype to the prototype of the parent constructor, allows to call <code>new F()</code> and create objects that have no properties of their own, but inherit everything from the parent's prototype.  </p>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>A temporary constructor <code>new F()</code></h2>

<h3>How to do it</h3>

<div class="highlight"><pre lang="js">function Shape() {}

// augment prototype
Shape.prototype.name = 'shape';
Shape.prototype.toString = function() {
    return this.name;
};
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>A temporary constructor <code>new F()</code></h2>

<h3>How to do it</h3>

<div class="highlight"><pre lang="js">function Triangle(side, height) {
  this.side = side;
  this.height = height;
}

// take care of inheritance
var F = function() {};
F.prototype = Shape.prototype;


Triangle.prototype = new F();
Triangle.prototype.constructor = Triangle;

// augment prototype
Triangle.prototype.name = 'Triangle';
Triangle.prototype.getArea = function() { return this.side * this.height / 2; };
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>A temporary constructor <code>new F()</code></h2>

<h3>Testing this approach</h3>

<div class="highlight"><pre lang="js">var my = new Triangle(5, 10);
my.getArea();  // 25
my.toString(); // "Triangle"
</pre></div>

<p>Using this approach, we keep the prototype chain in place <br /><br />and the parents' properties are not overwritten by the children. <br /><br />In fact:</p>

<div class="highlight"><pre lang="js">var s = new Shape();
s.name; // "shape"
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>A temporary constructor <code>new F()</code></h2>

<h3>The idea behind</h3>

<p>This approach supports the idea that:</p>

<ul>
<li>only properties and methods added to the prototype should be inherited, and</li>
<li>own properties should not be inherited.</li>
</ul>
</article>


<!-- slide -->


<article>
<h2>Isolating the inheritance part into a function</h2>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Isolating the inheritance part into a function</h2>

<h3><code>inherits(Child, Parent)</code></h3>

<p>Let's move the code that takes care of all of the inheritance details into a reusable <code>inherits()</code> function:</p>

<div class="highlight"><pre lang="js">function inherits(Child, Parent) {
  var F = function() {};
  F.prototype = Parent.prototype;
  Child.prototype = new F();
  Child.prototype.constructor = Child;
}
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Isolating the inheritance part into a function</h2>

<h3><code>inherits(Child, Parent)</code></h3>

<p>Using this function (or your own custom version of it) will help you keep your code clean with regard to the repetitive inheritance-related tasks. <br /><br />This way you can inherit by simply using:</p>

<div class="highlight"><pre lang="js">inherits(Child, Parent);
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Isolating the inheritance part into a function</h2>

<h3>Applying <code>inherits(Child, Parent)</code> function</h3>

<div class="highlight"><pre lang="js">function Shape() {}

// augment prototype
Shape.prototype.name = 'shape';
Shape.prototype.toString = function() {
    return this.name;
};
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Isolating the inheritance part into a function</h2>

<h3>Applying <code>inherits(Child, Parent)</code> function</h3>

<div class="highlight"><pre lang="js">function Triangle(side, height) {
    this.side = side;
    this.height = height;
}

// take care of inheritance
inherits(Triangle, TwoDShape);

// augment prototype
Triangle.prototype.name = 'Triangle';
Triangle.prototype.getArea = function() { return this.side * this.height / 2; };
</pre></div>
</article>


<!-- slide -->


<article>
<h1>Inheritance</h1>

<h2>Isolating the inheritance part into a function</h2>

<h3>Testing <code>inherits(Child, Parent)</code> function</h3>

<div class="highlight"><pre lang="js">var my = new Triangle(5, 10);
my.getArea();  // 25
my.toString(); // "Triangle"

var shape = Shape();
shape.name; //"Shape"
</pre></div>
</article>


<script>
var slides;
var current = 0;
var next;
var max = Math.max;
var min = Math.min;

function init () {
  slides = document.querySelectorAll('article');

  //hide all
  for (var i = 0; i < slides.length; i += 1) {
    slides[i].style.display = 'none';
  }

  //show the first
  slides[0].style.display = 'block';

  //handle slide change
  document.addEventListener('keydown', function (event) {
    var code = event.keyCode;

    if (code === 37 || code === 38) {
      next = current - 1;
      if (next >= 0) {
        slides[current].style.display = 'none';
        slides[next].style.display = 'block';
        current = next;
      }
    } else if (code === 39 || code === 40) {
      next = current + 1;
      if (next < slides.length) {
        slides[current].style.display = 'none';
        slides[next].style.display = 'block';
        current = next;
      }
    } else if (code === 8) {
      slides[current].style.display = 'none';
      current = 0;
      slides[current].style.display = 'block';
    }

    console.log('current slide: ' + current);
  });
}

document.onreadystatechange = function () {
  if (document.readyState == "complete") {
    init();
  }
}
</script>
</body>
</html>